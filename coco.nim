## This module is the API behind the binary Coco.
##
## Coco makes line or branch code coverage for Nim a breeze. 
##      - Depends on LCOV
##      - Generates a nice looking HTML report
##      - Works with visualization tools like Coverage Gutters on VSCode.

import glob, strutils, os, strformat, sequtils

proc is_successful(ret: int): bool =
    if ret == 0:
        true
    else:
        false

proc exit_on_fail(success: bool): void {.discardable.} =
    if not success:
        quit("Command line failed. Coco exited.")
proc exec(command: string): void {.discardable.} =
    ## Wrapper around execShellCmd that exits if the command fail
    execShellCmd(command)
    .is_successful()
    .exit_on_fail()

proc get_cache_folder*(filename, nimcache: string, increment=0): string =
    &"{nimcache}/{filename}_{increment}_cov"

proc compile*(target="tests/**/*.nim", nimcache="nimcache", verbose=false, options= "") =
    ## Compiles Nim files in coverage mode
    ##      - target should be a Glob with a .nim extension
    var nim_args = "--hints:off"
    if verbose:
        nim_args = ""
    if options.len > 0:
        nim_args &= &" {options}"

    var i = 0 # used to avoid name folder conflicts
    for nimfile in walkGlob(target):
        var cache_folder = 
            nimfile
            .extractFilename()
            .get_cache_folder(nimcache, i)

        exec(&"nim {nim_args} --nimcache={cache_folder} --debugger:native --passC:--coverage --passL:--coverage c " & nimfile)
        i.inc()

proc reset_coverage*(source="lcov.info", path="coverage", nimcache="nimcache") =
    ## Removes everything generated by a past code coverage generation:
    ##      - Nimcache folder
    ##      - .info
    ##      - Code coverage report folder
    exec(&"rm -rf {source} {path} {nimcache}")

proc trace*(target: string) = 
    ## Runs the compiled Nim files to produce coverage informations.
    ##      - target should be a Glob with a .nim extension.
    
    for nimfile in walkGlob(target):
        var bin = nimfile
        removeSuffix(bin, ".nim")
        exec("./" & bin)

proc build_lcov_args(verbose=false, branch=false): string =
    ## Simple LCOV arguments wrapper
    var lcov_args = "--quiet"
    if verbose:
        lcov_args = ""
    if branch:
        lcov_args &= " --rc lcov_branch_coverage=1"
    lcov_args

proc cleanup_report*(fileinfo = "lcov.info", cov: string, verbose=false, branch=false) =
    ## Keeps only relevant coverage informations
    ##      Without any cleanup, your code coverage report will include standard libraries, tests and so on.
    
    var lcov_args = build_lcov_args(verbose, branch)
    var options: GlobOptions = {GlobOption.Directories, GlobOption.Absolute}
    
    # Remove standard lib and nimble pkgs informations
    var currentFolder = absolutePath("")
    exec(&"""lcov {lcov_args} --extract {fileinfo} "{currentFolder}*" -o {fileinfo}""")

    for pattern in cov.split(","):
        if pattern.startsWith("!"):
            var pattern_noprefix = pattern
            removePrefix(pattern_noprefix, "!")
            for path in walkGlob(pattern_noprefix, "", options):
                exec(&"""lcov {lcov_args} --remove {fileinfo} "{path}*" -o {fileinfo}""")
        else:
            for path in walkGlob(pattern, "", options):
                exec(&"""lcov {lcov_args} --extract {fileinfo} "{path}*" -o {fileinfo}""")

proc genhtml*(source="lcov.info", path="coverage", verbose=false, branch=false) =
    ## Generates the HTML code coverage report from a .info file generated by LCOV
    var lcov_args = "--quiet"
    if verbose:
        lcov_args = ""
    if branch:
        lcov_args &= " --branch-coverage"
    ## Generate LCOV Html report
    exec(&"genhtml {lcov_args} -o {path} {source}")

proc coverage*(target="tests/**/*.nim", cov="!tests", verbose=false, branch=false, nimcache="nimcache", report_source="lcov.info", report_path="coverage", compiler=""): int =
    ## ____
    ## 
    ## Code coverage for Nim:
    ##      1. Clean up past reports
    ##      2. Compile nim files in coverage mode
    ##      3. Run the the executables
    ##      4. Capture, produce and cleanup LCOV .info file
    ##      5. Generate the HTML report
    ##
    reset_coverage(report_source, report_path, nimcache)

    var targets = target.split(",")
    for target in targets:
        compile(target, nimcache, verbose, compiler)
    
    var lcov_args = build_lcov_args(verbose, branch)

    exec(&"lcov {lcov_args} --base-directory . --directory {nimcache} --zerocounters -q")
    for target in targets:
        trace(target)
   
    exec(&"lcov {lcov_args}  --base-directory . --directory {nimcache} -c -o {report_source}")

    cleanup_report(report_source, cov, verbose, branch)
    genhtml(report_source, report_path, verbose, branch)

    result = 0


when isMainModule:
    import cligen
    var helpOptions = {
        "target": "Nim files to compile and run in coverage mode. Support glob patterns.",
        "cov": "Path to folders and files you want in your code coverage report. Default takes your current directory and excludes your tests/ folder.",
        "verbose": "Displays every traces from LCOV and Nim"
    }
    dispatch(coverage, 
        help = {
        "target": "Nim files to compile and run in coverage mode. Direct path or glob patterns.",
        "cov": "Path to folders and files you want in your code coverage report. Default takes your current directory and excludes tests/ folder. Support glob patterns. ",
        "verbose": "Displays all traces coming from LCOV and Nim",
        "branch": "Enables LCOV branch code coverage mode",
        "nimcache": "Nimcache path used by the Nim compiler",
        "report_source": "Path used by LCOV to generate the file .info",
        "report_path": "Folder path where the HTML code coverage report will be created",
        "compiler": "Forward your parameter(s) to the Nim compiler"
        },
        short = {
        "report_source": 's',
        "report_path": 'p',
        "compiler": 'o'
        }
    ) 